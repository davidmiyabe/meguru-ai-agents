"""Workflow primitives for the conversational planning loop."""

from __future__ import annotations

import json
from dataclasses import dataclass, field
from typing import Any, Dict, List, Mapping, MutableMapping, Sequence

from meguru.agents import (
    Clarifier,
    Curator,
    Editor,
    Listener,
    Planner,
    Stylist,
)


def _coerce_positive_int(value: object) -> int | None:
    if isinstance(value, bool):
        return None
    if isinstance(value, int):
        return value if value > 0 else None
    if isinstance(value, float) and value.is_integer():
        numeric = int(value)
        return numeric if numeric > 0 else None
    if isinstance(value, str):
        cleaned = value.strip()
        if not cleaned:
            return None
        try:
            numeric = int(cleaned)
        except ValueError:
            return None
        return numeric if numeric > 0 else None
    try:
        numeric = int(str(value).strip())
    except (TypeError, ValueError):
        return None
    return numeric if numeric > 0 else None


@dataclass
class PlanConversationUpdate:
    """Represents the user and assistant messages generated by the workflow."""

    user_message: str | None = None
    assistant_chunks: List[str] = field(default_factory=list)
    clarifier_active: bool = False


class PlanConversationWorkflow:
    """Coordinates the listener, clarifier, curator, stylist, planner, and editor."""

    def __init__(self) -> None:
        self.listener = Listener()
        self.clarifier = Clarifier()
        self.curator = Curator()
        self.stylist = Stylist()
        self.planner = Planner()
        self.editor = Editor()

    @staticmethod
    def ensure_conversation(state: MutableMapping[str, Any]) -> MutableMapping[str, Any]:
        """Ensure the conversation scaffold exists on the wizard state."""

        conversation = state.setdefault("conversation", {})
        conversation.setdefault("messages", [])
        conversation.setdefault("pending_fields", [])
        return conversation

    def process_action(
        self,
        state: MutableMapping[str, Any],
        action: Mapping[str, Any],
    ) -> PlanConversationUpdate:
        """Process a user action and return the conversation delta."""

        conversation = self.ensure_conversation(state)
        pending_fields: Sequence[str] = list(conversation.get("pending_fields", []))

        listener_result = self.listener.run(
            action_json=json.dumps(action),
            context=state,
            pending_fields=pending_fields,
        )

        self._apply_updates(state, listener_result.context_updates)

        remaining_pending = [
            field for field in pending_fields if field not in listener_result.resolved_fields
        ]

        update = PlanConversationUpdate(user_message=listener_result.user_message or None)

        if listener_result.missing_context:
            deduped = list(dict.fromkeys(listener_result.missing_context))
            conversation["pending_fields"] = deduped
            clarifier_prompt = self.clarifier.run(deduped, state)
            update.assistant_chunks = clarifier_prompt.chunks
            update.clarifier_active = True
            return update

        conversation["pending_fields"] = remaining_pending

        curator_draft = self.curator.run(listener_result, state)
        styled = self.stylist.run(curator_draft, state.get("vibe", []))
        update.assistant_chunks.extend(styled.chunks)

        if listener_result.trigger_planning and self._has_prioritised_activity(state):
            activities = self._collect_activity_details(state)
            brief = self.planner.run(activities, str(state.get("destination") or ""))
            editor_revision = self.editor.run(brief, state)
            update.assistant_chunks.extend(editor_revision.chunks)

        return update

    @staticmethod
    def _apply_updates(state: MutableMapping[str, Any], updates: Mapping[str, Any]) -> None:
        if not updates:
            return

        if updates.get("destination"):
            state["destination"] = str(updates["destination"]).strip()

        if updates.get("group_type"):
            state["group_type"] = str(updates["group_type"])

        if updates.get("group_size"):
            state["group_size"] = int(updates["group_size"])

        if updates.get("travel_pace"):
            state["travel_pace"] = str(updates["travel_pace"])

        if updates.get("budget"):
            state["budget"] = str(updates["budget"])

        if updates.get("timing_note"):
            state["timing_note"] = str(updates["timing_note"])

        if updates.get("notes_append"):
            addition = str(updates["notes_append"]).strip()
            if addition:
                existing = str(state.get("notes", "")).strip()
                state["notes"] = f"{existing}\n{addition}".strip() if existing else addition

        if updates.get("vibe_add"):
            current = {str(item) for item in state.get("vibe", []) if isinstance(item, str)}
            for vibe in updates["vibe_add"]:
                if vibe:
                    current.add(str(vibe))
            state["vibe"] = sorted(current)

        catalog = state.setdefault("_activity_catalog", {})

        for card_id in updates.get("liked_cards_add", []) or []:
            if card_id not in state["liked_cards"]:
                state["liked_cards"].append(card_id)
        for card_id in updates.get("liked_cards_remove", []) or []:
            if card_id in state["liked_cards"]:
                state["liked_cards"].remove(card_id)

        for card_id in updates.get("saved_cards_add", []) or []:
            if card_id not in state["saved_cards"]:
                state["saved_cards"].append(card_id)
        for card_id in updates.get("saved_cards_remove", []) or []:
            if card_id in state["saved_cards"]:
                state["saved_cards"].remove(card_id)

        activity_updates = updates.get("activity_catalog", {})
        if isinstance(activity_updates, Mapping):
            for card_id, details in activity_updates.items():
                if isinstance(details, Mapping):
                    catalog[str(card_id)] = dict(details)

        PlanConversationWorkflow._refresh_activity_collections(state)

    @staticmethod
    def _has_prioritised_activity(state: Mapping[str, Any]) -> bool:
        if state.get("saved_inspirations") or state.get("liked_inspirations"):
            return True
        return bool(state.get("liked_cards") or state.get("saved_cards"))

    @staticmethod
    def _refresh_activity_collections(state: MutableMapping[str, Any]) -> None:
        catalog: Mapping[str, Mapping[str, Any]] = state.get("_activity_catalog", {}) or {}

        def _collect(
            card_ids: List[str],
            *,
            priority: str,
            existing: Dict[str, Mapping[str, Any]],
        ) -> List[Dict[str, Any]]:
            collected: List[Dict[str, Any]] = []
            for card_id in card_ids:
                details: Mapping[str, Any] | None = catalog.get(card_id)
                if not details:
                    details = existing.get(card_id)
                if not details:
                    details = {"id": card_id}
                payload = dict(details)
                payload.setdefault("id", card_id)
                payload.setdefault("priority", priority)
                collected.append(payload)
            return collected

        existing_saved = {
            str(item.get("id")): item
            for item in state.get("saved_inspirations", [])
            if isinstance(item, Mapping) and item.get("id")
        }
        existing_liked = {
            str(item.get("id")): item
            for item in state.get("liked_inspirations", [])
            if isinstance(item, Mapping) and item.get("id")
        }

        state["saved_inspirations"] = _collect(
            [str(card_id) for card_id in state.get("saved_cards", [])],
            priority="saved",
            existing=existing_saved,
        )
        state["liked_inspirations"] = _collect(
            [str(card_id) for card_id in state.get("liked_cards", [])],
            priority="liked",
            existing=existing_liked,
        )

    @staticmethod
    def _collect_activity_details(state: Mapping[str, Any]) -> List[Mapping[str, Any]]:
        ordered: List[Mapping[str, Any]] = []
        seen_ids: set[str] = set()

        for entry in state.get("saved_inspirations", []) or []:
            if isinstance(entry, Mapping):
                card_id = str(entry.get("id") or entry.get("title") or "")
                if card_id and card_id not in seen_ids:
                    ordered.append(dict(entry))
                    seen_ids.add(card_id)

        for entry in state.get("liked_inspirations", []) or []:
            if isinstance(entry, Mapping):
                card_id = str(entry.get("id") or entry.get("title") or "")
                if card_id and card_id not in seen_ids:
                    ordered.append(dict(entry))
                    seen_ids.add(card_id)

        return ordered

    @staticmethod
    def ready_for_gallery(state: Mapping[str, Any]) -> bool:
        conversation = state.get("conversation") or {}
        if conversation.get("pending_fields"):
            return False

        if not str(state.get("destination", "")).strip():
            return False

        has_timing = False
        if state.get("start_date") and state.get("end_date"):
            has_timing = True
        elif state.get("flexible_months"):
            has_timing = True
        elif str(state.get("timing_note", "")).strip():
            has_timing = True

        if not has_timing:
            return False

        if not state.get("vibe"):
            return False
        if not str(state.get("travel_pace", "")).strip():
            return False
        if not str(state.get("budget", "")).strip():
            return False

        group_type = str(state.get("group_type", "")).strip()
        if not group_type and _coerce_positive_int(state.get("group_size")) is None:
            return False

        return True


__all__ = ["PlanConversationUpdate", "PlanConversationWorkflow"]

